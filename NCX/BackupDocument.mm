/*
	File:		BackupDocument.mm

	Abstract:	NCX backup document.
					That’s the .nbku document type generated by NCXv1.
					We read in NSOF streams and create a CoreData model.
					It’s only RAM-resident: no point in making it persistent on disk.

	Written by:	Newton Research, 2012.
*/

#define forAppDebug 0

#import "BackupDocument.h"
#import "NCWindowController.h"
#import "Utilities.h"

extern "C" Ref FFindStringInArray(RefArg inRcvr, RefArg inArray, RefArg inStr);


/* -----------------------------------------------------------------------------
	D a t a
----------------------------------------------------------------------------- */
// soup entry table column defs
extern NSDictionary * gSlotDict;

NSString * const NSNewtonErrorDomain = @"NewtonErrorDomain";


/* -----------------------------------------------------------------------------
	N B D o c u m e n t
	Created from NCXv1 .nbku file.
----------------------------------------------------------------------------- */
@implementation NBDocument

/* -----------------------------------------------------------------------------
	Initialize a new instance for reading.
----------------------------------------------------------------------------- */

- (id)init {
	if (self = [super init]) {
		self.objContext = [self managedObjectContext];
		self.objEntities = self.objContext.persistentStoreCoordinator.managedObjectModel.entitiesByName;
		[self.objContext setUndoManager: nil];

		// init state
		self.windowController.progressText = @"Newton Connection v1.x data.";
		self.screenshot = nil;
		self.isReadOnly = YES;
	}
	return self;
}


/* -----------------------------------------------------------------------------
	Read document from file.
	The file format looks like:
		char				signature[8]		must be "backup0"
		unsigned long	version				SourceInfo read during dock connection protocol
		unsigned long	manufacturer
		unsigned long	machineType
		NSOF stream		storeRef				only one store is represented
		 NSOF stream	 soupRef				the store contains many soups
		  NSOF stream	  entryRef			each soup contains many entries
													each stream of NSOF objects is terminated by a nil object
----------------------------------------------------------------------------- */

- (BOOL)readFromURL:(NSURL *)url ofType:(NSString *)typeName error:(NSError **)outError
{
	const char * filePathStr = url.fileSystemRepresentation;
	CStdIOPipe pipe(filePathStr, "r");
	BackupFileHeader header;
	size_t size = sizeof(header);
	bool isEOF;
	NSError * errObj = nil;

	// file must be prefixed with 'backup0'
	pipe.readChunk(&header, size, isEOF);
	if (strncmp(header.signature, "backup", 6) != 0)
		return NO;

#if defined(hasByteSwapping)
	// this backup file MAY have been created on a (big-endian) PPC machine
	if ((header.source.machineType & 0xFFFF0000) != 0x10000000
	&&   header.source.machineType != 0x00726377)
	{
		header.source.version = BYTE_SWAP_LONG(header.source.version);
		header.source.manufacturer = BYTE_SWAP_LONG(header.source.manufacturer);
		header.source.machineType = BYTE_SWAP_LONG(header.source.machineType);
	}
#endif

	// device object is root of persistent data
	self.deviceObj = [self makeDevice: [[[url path] lastPathComponent] stringByDeletingPathExtension] source: &header.source];

	// first object is store info
	RefVar storeRef(UnflattenRef(pipe));
	// convert to persistent NCStore object
	NCStore * storeObj = [self makeStore: storeRef];
	[self.deviceObj addStoresObject: storeObj];

	// start with a list of all the soups on this store
	// - we’re going to remove soups from this list as we encounter them in applications
	RefVar allSoups(GetFrameSlot(storeRef, MakeSymbol("soups")));
	// catch errors so we can report them
	newton_try
	{
		RefVar allApps(GetFrameSlot(storeRef, MakeSymbol("apps")));
		FOREACH(allApps, app)
			NCApp * appObj = [self makeApp: MakeNSString(GetFrameSlot(app, SYMA(name)))];
			RefVar soupIndexes, soupInfoRef, soupEntry;
			RefVar appSoups(GetFrameSlot(app, MakeSymbol("soups")));
			FOREACH(appSoups, soupName)
				NSRange indexesRange;
				indexesRange.location = pipe.readPosition();
				soupIndexes = UnflattenRef(pipe);
				indexesRange.length = pipe.readPosition() - indexesRange.location;

				NSRange infoRange;
				infoRange.location = pipe.readPosition();
				soupInfoRef = UnflattenRef(pipe);
				infoRange.length = pipe.readPosition() - infoRange.location;

				NCSoup * soupObj = [self makeSoup: MakeNSString(soupName) fromData: pipe indexesRange: indexesRange infoRange: infoRange info: soupInfoRef];
				[storeObj addSoupsObject: soupObj];
				[appObj addSoupsObject: soupObj];

				NSRange entryRange;
				while (entryRange.location = pipe.readPosition(), NOTNIL(soupEntry = UnflattenRef(pipe))) {
					entryRange.length = pipe.readPosition() - entryRange.location;
					[soupObj addEntry: soupEntry fromData: pipe range: entryRange];
				}

				// remove this soup from the master list
				Ref index;
				if (NOTNIL(index = FFindStringInArray(RA(NILREF), allSoups, soupName)))
					ArrayRemoveCount(allSoups, (ArrayIndex)RINT(index), 1);

			END_FOREACH	// soup
		END_FOREACH	// app
	}
	newton_catch_all
	{
		NewtonErr err = (NewtonErr)(long)CurrentException()->data;
		NSDictionary * errDict = @{ NSLocalizedDescriptionKey: [NSString stringWithFormat: @"Newton error %d occurred when reading the backup stream.", err],
											 NSLocalizedRecoverySuggestionErrorKey: @"You should not rely on this Newton backup file. Perform another backup and report this problem to simonbell@me.com." };
		errObj = [NSError errorWithDomain: NSNewtonErrorDomain code: err userInfo: errDict];
	}
	end_try;

	if (errObj) {
		*outError = errObj;
		return NO;
	}

	// make the (remaining) soups node
	// these soups are reported in the store info but are not part of any app, so are not backed up
	if (Length(allSoups) > 0) {
		RefVar nothing(AllocateFrame());
		NSRange noRange = NSMakeRange(NSNotFound, 0);
		FOREACH(allSoups, soupName)
			NCSoup * soupObj = [self makeSoup: MakeNSString(soupName) fromData: pipe indexesRange: noRange infoRange: noRange info: nothing];
			[storeObj addSoupsObject: soupObj];
		END_FOREACH	// soup
	}

	[self setFileType: @"com.newton.device"];
	[self setFileURL: ApplicationSupportFile(self.deviceObj.name)];
//	[objStore setReadOnly:YES];

	return YES;
}


#pragma mark Construction from NSOF
/* -----------------------------------------------------------------------------
	Make a persistent device object.
	We only have SourceInfo to build this: not very informative.
	Args:		inStoreRef
	Return:	NCStore instance
----------------------------------------------------------------------------- */

- (NCDevice *)makeDevice:(NSString *)inName source:(SourceInfo *)inSource {

	NCDevice * device = [NSEntityDescription insertNewObjectForEntityForName: @"Device" inManagedObjectContext: self.objContext];
	device.user = [NSEntityDescription insertNewObjectForEntityForName: @"UserInfo" inManagedObjectContext: self.objContext];
	device.user.font = nil;
	device.user.folders = nil;

	NewtonInfo info;
	memset(&info, 0, sizeof(info));
	info.fNOSVersion = inSource->version;
	info.fManufacturer = inSource->manufacturer;
	info.fMachineType = inSource->machineType;

	device.name = inName;
	device.info = [NSData dataWithBytes: &info length: sizeof(NewtonInfo)];

	return device;
}

/* -----------------------------------------------------------------------------
	Make a persistent store object.
	Args:		inStoreRef
	Return:	NCStore instance
----------------------------------------------------------------------------- */

- (NCStore *)makeStore:(RefArg)inStoreRef {

	NCStore * store = [NSEntityDescription insertNewObjectForEntityForName: @"Store" inManagedObjectContext: self.objContext];

	store.name = MakeNSString(GetFrameSlot(inStoreRef, SYMA(name)));
	store.kind = MakeNSString(GetFrameSlot(inStoreRef, SYMA(kind)));
	store.signature = [NSNumber numberWithInteger:RINT(GetFrameSlot(inStoreRef, MakeSymbol("signature")))];
	// is version really of any interest?
	store.storeVersion = [NSNumber numberWithInteger:RINT(GetFrameSlot(inStoreRef, MakeSymbol("storeVersion")))];
	store.totalSize = [NSNumber numberWithInteger:RINT(GetFrameSlot(inStoreRef, MakeSymbol("totalSize")))];
	store.usedSize = [NSNumber numberWithInteger:RINT(GetFrameSlot(inStoreRef, MakeSymbol("usedSize")))];
	store.readOnly = [NSNumber numberWithBool:NOTNIL(GetFrameSlot(inStoreRef, MakeSymbol("readOnly")))];

	NSString * str = MakeNSString(GetFrameSlot(inStoreRef, MakeSymbol("storePassword")));
	if (str == nil)
		str = @"";
	store.storePassword = str;

	return store;
}


/* -----------------------------------------------------------------------------
	Make a persistent app object.
	Args:		inName
	Return:	NCApp instance
----------------------------------------------------------------------------- */

- (NCApp *)makeApp:(NSString *)inName {
	NCApp * app = [NSEntityDescription insertNewObjectForEntityForName: @"App" inManagedObjectContext: self.objContext];
	app.name = inName;
	return app;
}


/* -----------------------------------------------------------------------------
	Make a persistent soup object.
	Args:		inName
				inPipe
				indexesRange
				infoRange
				info
	Return:	NCSoup instance
----------------------------------------------------------------------------- */

- (NCSoup *)makeSoup:(NSString *)inName fromData:(CStdIOPipe &)inPipe indexesRange:(NSRange)indexesRange infoRange:(NSRange)infoRange info:(RefArg)info {

	NCSoup * soup = [NSEntityDescription insertNewObjectForEntityForName: @"Soup" inManagedObjectContext: self.objContext];
	soup.name = inName;
	soup.lastImportId = [NSNumber numberWithUnsignedInt: kImportIdBase];

	if (NOTNIL(info)) {
		bool isEOF;
		long savedPosition = inPipe.readPosition();

		size_t len = indexesRange.length;
		void * nsof = malloc(len);
		inPipe.readSeek(indexesRange.location, SEEK_SET);
		inPipe.readChunk(nsof, len, isEOF);
		soup.indexes = [NSData dataWithBytesNoCopy: nsof length: len];

		len = infoRange.length;
		nsof = malloc(len);
		inPipe.readSeek(infoRange.location, SEEK_SET);
		inPipe.readChunk(nsof, len, isEOF);
		soup.info = [NSData dataWithBytesNoCopy: nsof length: len];

		inPipe.readSeek(savedPosition, SEEK_SET);

		// assume there’s no soupDef, or it’s not fully slotted
		soup.descr = @"No soup definition.";
		soup.appName = @"--";

		RefVar item;
		RefVar soupDef(GetFrameSlot(info, MakeSymbol("soupDef")));
		if (NOTNIL(soupDef)) {
			item = GetFrameSlot(soupDef, SYMA(name));
			if (NOTNIL(item))
				soup.name = MakeNSString(item);

			item = GetFrameSlot(soupDef, MakeSymbol("userDescr"));
			if (NOTNIL(item))
				soup.descr = MakeNSString(item);

			item = GetFrameSlot(soupDef, MakeSymbol("ownerAppName"));
			if (NOTNIL(item))
				soup.appName = MakeNSString(item);
			else {
			// if no ownerAppName use ownerApp symbol
				item = GetFrameSlot(soupDef, MakeSymbol("ownerApp"));
				if (NOTNIL(item))
					soup.appName = [NSString stringWithCString:SymbolName(item) encoding:NSMacOSRomanStringEncoding];
			}
		}

		Ref timeRef = GetFrameSlot(info, MakeSymbol("NCKLastBackupTime"));
		if (ISNIL(timeRef))
			timeRef = MAKEINT(0);
		soup.lastBackupTime = [NSNumber numberWithUnsignedLong:RVALUE(timeRef)];

	} else {
		// all we have is the (orphan) soup name
		soup.indexes = nil;
		soup.info = nil;

		soup.descr = @"Orphan soup - no definition.";
		soup.appName = @"--";
		soup.lastBackupTime = [NSNumber numberWithUnsignedLong:0];
	}

	return soup;
}

@end


@implementation NCSoup (forNCX1)
/* -----------------------------------------------------------------------------
	Make a persistent soup entry object.
	Args:		inEntry
				inPipe
				inRange
	Return:	NCEntry instance
----------------------------------------------------------------------------- */

- (NCEntry *)addEntry:(RefArg)inEntry fromData:(CStdIOPipe &)inPipe range:(NSRange)inRange {
	size_t numOfBytes;
	void * data;

	if (self.app.isPackages) {
		if (FrameHasSlot(inEntry, MakeSymbol("pkgRef"))) {
			SetFrameSlot(inEntry, SYMA(class), MakeSymbol("*package*"));
			numOfBytes = FlattenRefSize(inEntry);
			data = malloc(numOfBytes);

			CPtrPipe pipe;
			pipe.init(data, numOfBytes, NO, nil);
			FlattenRef(inEntry, pipe);
		} else {
		// ignore it -- we’re only interested in pkgRef entries
			return nil;
		}

	} else {
		bool isEOF;
		long savedPosition = inPipe.readPosition();
		numOfBytes = inRange.length;
		data = malloc(numOfBytes);
		inPipe.readSeek(inRange.location, SEEK_SET);
		inPipe.readChunk(data, numOfBytes, isEOF);
		inPipe.readSeek(savedPosition, SEEK_SET);
	}

	NCEntry * entry = [self addEntry:inEntry withNSOFData:data length:numOfBytes];
	free(data);
	return entry;
}

@end
