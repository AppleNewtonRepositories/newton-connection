/*	File:		DynamicArray.h	Contains:	Interface to the CDynamicArray class.	Written by:	Newton Research Group.*/#if !defined(__DYNAMICARRAY_H)#define __DYNAMICARRAY_H 1#if !defined(__NEWTON_H)#include "Newton.h"#endif/*------------------------------------------------------------------------------	Forward and external class declarations------------------------------------------------------------------------------*/class CArrayIterator;	// CArrayIterator knows how to traverse a CDynamicArray.	// In particular, it will bend indices to account for on-the-fly	// element insertion and deletion.typedef unsigned int ArrayIndex;#define kEmptyIndex 0xFFFFFFFF/*------------------------------------------------------------------------------	C D y n a m i c A r r a y------------------------------------------------------------------------------*/class CDynamicArray : public SingleObject{public:	enum Parameters	{		kDefaultElementSize = 4,		kDefaultChunkSize = 4	};						CDynamicArray();						CDynamicArray(unsigned int inElementSize, ArrayIndex inChunkSize);						~CDynamicArray();// array manipulation primitives	ArrayIndex		getArraySize(void);	NewtonErr		setArraySize(ArrayIndex inSize);	NewtonErr		setElementCount(ArrayIndex inSize);		// like setArraySize, but sets logical size, too	void *			elementPtrAt(ArrayIndex index);	void *			safeElementPtrAt(ArrayIndex index);	NewtonErr		getElementsAt(ArrayIndex index, void * outElements, ArrayIndex inCount);	NewtonErr		addElement(void * inElement);	NewtonErr		insertElementsBefore(ArrayIndex index, void * inElements, ArrayIndex inCount);	NewtonErr		replaceElementsAt(ArrayIndex index, void  * inElements, ArrayIndex inCount);	NewtonErr		removeElementsAt(ArrayIndex index, ArrayIndex inCount);	NewtonErr		removeAll(void);// miscellaneous functions	BOOL				isEmpty(void);	NewtonErr		merge(CDynamicArray * inArray);// don't call this unless you know what you are doing.  Just say NO!	void				nukeIterator(void);		// Dangerousprotected:	unsigned int			computeByteCount(ArrayIndex inCount);	ArrayIndex		fSize;				// logical size of arrayprivate:	friend class CArrayIterator;	unsigned int			fElementSize;		// size of a single element	ArrayIndex		fChunkSize;			// grow/shrink array by this many elements	ArrayIndex		fAllocatedSize;	// physical size of array	void *			fArrayBlock;		// element storage	CArrayIterator *	fIterator;		// linked list of iterators active on this array};/*------------------------------------------------------------------------------	C D y n a m i c A r r a y   I n l i n e s------------------------------------------------------------------------------*/inline ArrayIndex CDynamicArray::getArraySize(void){ return fSize; }inline BOOL CDynamicArray::isEmpty(void){ return (fSize == 0); }inline void * CDynamicArray::elementPtrAt(ArrayIndex index){ return (Ptr)fArrayBlock + fElementSize * index; }inline unsigned int CDynamicArray::computeByteCount(ArrayIndex inCount){ return (fElementSize * inCount); }inline NewtonErr CDynamicArray::addElement(void * inElement){ return insertElementsBefore(fSize, inElement, 1); }inline NewtonErr CDynamicArray::removeAll(void){ return removeElementsAt(0, fSize); }inline void CDynamicArray::nukeIterator(void){ fIterator = NULL; }#endif	/*	__DYNAMICARRAY_H	*/