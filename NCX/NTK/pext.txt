/*	Ensure soups for built-in apps exist. */ssop := func(ep)beginlocal data := ep:ReadCommandData();DefineGlobalConstant('kSoupNames, {	paperroll: ROM_paperRollSoupName,												cardfile: ROM_cardfileSoupName,												calendar: [	ROM_calendarSoupName,																ROM_calendarNotesName,																ROM_repeatMeetingName,																ROM_repeatNotesName,																"To Do List"],												works: "NewtWorks" });local soup := kSoupNames.(data);if IsString(soup) then	GetUnionSoupAlways(soup);else if IsArray(soup) then	foreach name in soup do		GetUnionSoupAlways(name);ep:WriteCommand("dres", 0, true)end;/*	Return the folder symbol -> string translation table. */fold := func(ep)beginlocal data := ep:ReadCommandData();local folders := GetUserConfig('userFolders);ep:WriteCommand("fldr", folders, true)end;/*	Toggle screenshot capture. */scrn := func(ep)beginlocal data := ep:ReadCommandData();local err := 0;local ntp := GetRoot().newtoolspro;if ntp then	begin	local dock := GetRoot().connection;	if dock.ToggleScreenCapture = nil then		begin		dock.ToggleScreenCapture := func()			begin			local killCaptureFn := func()				begin				captureCookie := nil;				AddDeferredSend(self, 'ToggleScreenCapture, nil)				end;			if captureOn then				begin				// stop screen capture				// if we’ve got a cookie then the notify icon is active and we need to kill it				// (otherwise we got here because the user tapped the notify icon so it’s gone anyway)				if captureCookie then					begin					GetRoot().NotifyIcon:KillAction(captureCookie);					captureCookie := nil					end;				captureOn := nil				end			else				begin				// start screen capture				captureCookie := GetRoot().NotifyIcon:AddAction("Dock", killCaptureFn, nil);				if whichConnection then					begin					theEndpoint:StopIdle(whichConnection);					whichConnection.closing := true					end;				:CloseOpenWindows(nil);				captureOn := true;				local err := 0;				try					theEndpoint:SetState(9)				onexception |evt.ex| do					begin					err := CurrentException().error;					if theEndpoint then theEndpoint:ConnectionDone(err)					end				end			end;		dock.captureCookie := nil;		dock.captureOn := nil		end;	dock:ToggleScreenCapture()	endelse	// no ntp	err := -28010;ep:WriteCommand("dres", err, true)end;/*	Take a screenshot. */snap := func(ep)beginlocal data := ep:ReadCommandData();local ntp := GetRoot().newtoolspro;if ntp then	begin	local theShot := {};	ntp._proto:ScreenShotFn(theShot);	ep:WriteCommand("shot", theShot, true)	endelse	// no ntp	begin	ep:WriteCommand("dres", -28010, true)	endend;/*	Return a 4K page of memory for ROM dump etc. */reqp := func(ep)beginlocal data := ep:ReadCommandData();if IsInteger(data) then	begin	local thePage := MakeBinary(4096, 'page);//	FetchPage(thePage, data);	ep:WriteCommand("page", thePage, true)	endelse	// bad start address	begin	ep:WriteCommand("dres", -1, true)	endend;/* Get soup entry summaries. */gent := func(ep)beginlocal data := ep:ReadCommandData();local didWeFindAnySoupsOnAnyStores;local theResults := [];local theStores := GetStores();foreach store in theStores do	try 	local theSoups := data.soups;	foreach soupName in theSoups do		begin		local theCurrentSoup := store:GetSoup(soupName);		if theCurrentSoup then			begin			didWeFindAnySoupsOnAnyStores := true;			local theCurrentQuery := theCurrentSoup:Query(nil);			local tempResults := MapCursor(theCurrentQuery,					func(theCurrentEntry)				//	if theCurrentEntry.class = 'drawPaper or theCurrentEntry.class = 'paper then	// original filters entries						begin						if not theCurrentEntry.labels then							theCurrentEntry.labels := 'unfiled;						local theInfoWeWant := {};						foreach slot in data.slotsWeWant do							begin							try theInfoWeWant.(slot) := theCurrentEntry.(slot)							onexception |evt.ex| do begin end							end;						if theCurrentEntry.class then							begin							local dataDef := GetDataDefs(theCurrentEntry.class);							if dataDef then								theInfoWeWant.app := dataDef.name							end;						theInfoWeWant.storeId := store:GetSignature();						theInfoWeWant.storeKind := store:GetKind();						theInfoWeWant.storeName := store:GetName();						theInfoWeWant						end);			ArrayMunger(theResults, Length(theResults), 0, tempResults, 0, nil)			end		end	onexception |evt.ex| do		begin		theExceptionBlock := CurrentException();		AddArraySlot(theResults, theExceptionBlock)		end;if Length(theResults) = 0 then	begin	if didWeFindAnySoupsOnAnyStores then		ep:WriteCommand("rent", theResults, true)	else		begin		theResults := nil;		ep:WriteCommand("rent", theResults, true)		end	endelse	ep:WriteCommand("rent", theResults, true)end;/* Empty the Names soup; but leave owner and worksite entries. */eNsp := func(ep)beginlocal theData := ep:ReadCommandData();local theStoreSignature := GetSlot(theData, 'signature);local theStore;if theStoreSignature then	// find store specified by signature	foreach store in GetStores() do		if store:GetSignature() = theStoreSignature then			begin			theStore := store;			break			end;if theStore then	begin	local soup := theStore:GetSoup(ROM_cardfileSoupName);	local querySpec := {tagSpec:{none:'_ownerNames},							  validTest: func(e) begin local entryClass := e.class; entryClass <> 'owner and entryClass <> 'worksite end};	local acursor := soup:Query(querySpec);	entry := acursor:Entry();	while entry do		begin		EntryRemoveFromSoup(entry);		entry := acursor:Next()		end;	ep:WriteCommand("dres", 0, true)	endelse	// no store	ep:WriteCommand("dres", -1, true)end;/*	Package Finder. */pfnd := func(ep)beginlocal isBad;local theData := ep:ReadCommandData();local theName := GetSlot(theData, 'packageName);local storeSignature := GetSlot(theData, 'signature);local theStore := GetDefaultStore();if storeSignature then	// find store specified by signature	foreach store in GetStores() do		if store:GetSignature() = storeSignature then			begin			theStore := store;			break			end;if theStore then	begin	local entry := GetPkgRef(theName, theStore);	if entry then		begin		// found the package		if IsProtocolPartInUse(entry) then			ep:WriteCommand("tran", nil, nil)		else			ep:WriteCommand("pkya", nil, nil)			end	else		// package not found		ep:WriteCommand("pkno", nil, nil)	endelse	// no store	begin	ep:WriteCommand("dres", -28001, true);	isBad := true	end;isBadend;/*	Nuke a package. */nuke := func(ep) begin	local isBad;	local theData := ep:ReadCommandData();	local pkgName := GetSlot(theData, 'packageName);	local storeSignature := GetSlot(theData, 'signature);	// find the specified store	local theStore := nil;	foreach store in GetStores() do		if store:GetSignature() = storeSignature then begin			theStore := store;			break		end;	if theStore then begin		local pkgEntry := GetPackageEntry(pkgName, theStore);		if pkgEntry then begin			if IsProtocolPartInUse(GetPkgRef(pkgName, theStore)) then				ep:WriteCommand("tran", nil, nil)			else begin				RemovePackage(pkgEntry);				ep:WriteCommand("dres", 0, true)			end		end else begin			// looks very like GetPackageEntry() without tagspec:'{all:_package} in the qrySpec			local pkgSoup := theStore:GetSoup("Packages");			if pkgSoup then begin				local qrySpec := { beginKey:pkgName, endKey:pkgName, indexPath:'packageName };				local acursor := pkgSoup:Query(qrySpec);				pkgEntry := acursor:Entry();				while pkgEntry do begin					EntryRemoveFromSoup(pkgEntry);					pkgEntry := acursor:Next()				end			end;			ep:WriteCommand("dres", 0, true)		end	end else begin		// no store		ep:WriteCommand("dres", kDBadStoreSignature, true);		isBad := true	end;	isBadend;/*	compare that with how Newton does it: rmvp ->voidCDocker::doRemovePackage(void){	RefVar pkgName(readRef(fTargetStore));	RefVar pkgEntry(NSCallGlobalFn(SYMA(GetPackageEntry), pkgName, fTargetStore));	if (NOTNIL(pkgEntry)) {		NSCallGlobalFn(SYMA(RemovePackage), pkgEntry);	}	writeResult(noErr);	addChangedSoup(SYMA(changed), true);}functions.GetPackageEntry := func(inPkgName, inStore) begin	local pkgSoup := inStore:GetSoup("Packages");	if pkgSoup then begin		local qrySpec := { beginKey:inPkgName, endKey:inPkgName, indexPath:'packageName, tagspec:'{all:_package} };		pkgSoup:Query(qrySpec):entry()	endendfunctions.RemovePackage := func(inPkgEntry) begin	local entry := PackageEntryFromThingy(inPkgEntry);	if not entry then		return;	local oldSoup := EntrySoup(entry);	local pkgStore := EntryStore(entry);	local pkgRef := entry.pkgRef;	local pkgInfo := GetPkgRefInfo(pkgRef);	foreach pkgPart in pkgInfo.parts do		if IsFrame(pkgPart) and pkgPart.DeletionScript then			try				pkgPart:DeletionScript()			onexception |evt.ex| do				begin end;	if IsPackageActive(pkgRef) then		DeActivatePackage(pkgRef);	pkgStore:AtomicAction(func() begin		// entry and oldSoup are closed over here		EntryRemoveFromSoup(entry);		UnsafeXmitSoupChangeNow("Packages", '_newt, 'entryRemoved, {oldSoup: oldSoup, entry: entry})	end);	trueend*//*	Ensure every item in the To Do List has a unique id (based on the current time in seconds). */ftod := func(ep)beginlocal theData := ep:ReadCommandData();local todoSoup := GetUnionSoup("To Do List");local theQuery := todoSoup:Query(nil);local theEntry := theQuery:Entry();while theEntry do	begin	local changedStuff := nil;	foreach value in theEntry.topics do		if HasSlot(value, 'unique) = nil and HasSlot(value, 'uniqueId) = nil then			begin			value.unique := TimeInSeconds() + Ticks();			Sleep(1);			changedStuff := true			end;	if changedStuff then		EntryChangeXmit(theEntry, nil);	theEntry := theQuery:Next()	end;ep:WriteCommand("dres", 0, true)end;/*	Get a soup info frame. */ginf := func(ep)beginlocal theData := ep:ReadCommandData();local theSoupName := GetSlot(theData, 'soupName);local theSymbol := GetSlot(theData, 'getInfoSymbol);try 	local theSoup := GetStores()[0]:GetSoup(theSoupName);	local theInfoFrame := theSoup:GetInfo(theSymbol);	ep:WriteCommand("rinf", theInfoFrame, true)onexception |evt.ex| do	ep:WriteCommand("dres", -1, true)end;/*	Create a meeting in Dates using location and invitees from Names (where available). */meet := func(ep)beginlocal theData := ep:ReadCommandData();local theLocation := GetSlot(theData, 'illocation);local thePeople := GetSlot(theData, 'ilinvitees);local mtgText := GetSlot(theData, 'mtgText);local mtgStartDate := GetSlot(theData, 'mtgStartDate);local errorNumber := 0;local theNamesSoup := GetUnionSoupAlways(ROM_cardfileSoupName);local theQuery, theEntry;if theLocation and IsString(theLocation) then	begin	try 		theQuery := theNamesSoup:Query({entirewords: true, words: [theLocation]});		theEntry := theQuery:Entry();		GetRoot().calendar:SetMeetingLocation(mtgText, mtgStartDate, if theEntry then theEntry else theLocation)	onexception |evt.ex| do		errorNumber := -1	end;if thePeople then	begin	local peopleArray := [];	try 		foreach thePerson in thePeople do			begin			local wordQueryArray := [];			local nameSlot := GetSlot(thePerson, 'name);			if HasSlot(nameSlot, 'first) then				AddArraySlot(wordQueryArray, GetSlot(nameSlot, 'first));			if HasSlot(nameSlot, 'last) then				AddArraySlot(wordQueryArray, GetSlot(nameSlot, 'last));			theQuery := theNamesSoup:Query({entirewords: true, words: wordQueryArray});			theEntry := theQuery:Entry();			AddArraySlot(peopleArray, if theEntry then theEntry else thePerson)			end;		GetRoot().calendar:SetMeetingInvitees(mtgText, mtgStartDate, peopleArray);	onexception |evt.ex| do		errorNumber := -2;	end;ep:WriteCommand("dres", errorNumber, true)end;/*	Modify the To Do List. */todo := func(ep)beginlocal GetTheEntryWeWant := func(storeID, refTopicFrame)	begin	local storesList := GetStores();	local ourStore := nil;	foreach entry in storesList do		if entry:GetSignature() = storeID then			break (ourStore := entry);	local todoSoup := ourStore:GetSoup("To Do List");	local theQuery := todoSoup:Query({validTest: func(soupEntry) soupEntry._uniqueID = refTopicFrame.entryID});	theQuery:Entry()	end;local errorNumber := 0;local theData := ep:ReadCommandData();local exportstate := GetSlot(theData, 'exportState);local refTopicFrame := GetSlot(theData, 'exportEntry);local storeID;local theQuery, theEntry := nil;if exportState = 'iladd then	begin	local todoUnionSoup := GetUnionSoup("To Do List");	local theNewToDo;	local remindForDate := refTopicFrame.topic.remindForDate;	local topicFrame := GetSlot(refTopicFrame, 'topic);	local reminderFrame := GetSlot(topicFrame, 'repeatInfo);	if reminderFrame then		begin		theQuery := todoUnionSoup:Query({validTest: func(soupEntry) if soupEntry.date = 0 then 1});		theEntry := theQuery:Entry();		if theEntry then			begin			refTopicFrame.topic.viewBounds := {left: 0, top: 0, right: 0, bottom: 0};			refTopicFrame.topic.unique := TimeInSeconds() + Ticks();			refTopicFrame.topic.styles := [];			refTopicFrame.topic.source := 0;			AddArraySlot(theEntry.topics, Clone(refTopicFrame.topic));			EntryChangeXmit(theEntry, nil)			end		else			begin			theNewToDo := Clone({class: 'todo, needsSort: nil, date: nil, topics: []});			theNewToDo.Date := refTopicFrame.date;			refTopicFrame.topic.viewBounds := {left: 0, top: 0, right: 0, bottom: 0};			refTopicFrame.topic.unique := TimeInSeconds() + Ticks();			refTopicFrame.topic.styles := [];			refTopicFrame.topic.source := 0;			AddArraySlot(theNewToDo.topics, Clone(refTopicFrame.topic));			todoUnionSoup:AddToDefaultStoreXmit(theNewToDo, nil);			theNewToDo := nil;			theEntry := nil			end		end	else		begin		theNewToDo := Clone({class: 'todo, needsSort: nil, date: nil, topics: []});		theNewToDo.Date := refTopicFrame.date;		refTopicFrame.topic.viewBounds := {left: 0, top: 0, right: 0, bottom: 0};		refTopicFrame.topic.unique := TimeInSeconds() + Ticks();		refTopicFrame.topic.styles := [];		refTopicFrame.topic.source := 0;		AddArraySlot(theNewToDo.topics, Clone(refTopicFrame.topic));		todoUnionSoup:AddToDefaultStoreXmit(theNewToDo, nil);		theNewToDo := nil;		theEntry := nil		end	endelse if exportState = 'ilreplace then	try 		storeID := GetSlot(theData, 'storeID);		theEntry := call GetTheEntryWeWant with (storeID, refTopicFrame);		if theEntry then			begin			local indexToTopicToFind := 0;			foreach entry in theEntry.topics do				if HasSlot(entry, 'uniqueId) then					begin					if entry.uniqueId <> refTopicFrame.topic.uniqueId then						indexToTopicToFind := indexToTopicToFind + 1					else						break					end				else if HasSlot(entry, 'unique) then					begin					if entry.unique <> refTopicFrame.topic.uniqueId then						indexToTopicToFind := indexToTopicToFind + 1					else						break					end;			local theTopicInfo := theEntry.topics[indexToTopicToFind];			foreach tag, val in refTopicFrame.topic do				if tag = 'uniqueId then					theTopicInfo.unique := val				else					theTopicInfo.(tag) := val;			EntryChangeXmit(theEntry, nil)			end	onexception |evt.ex| do		errorNumber := -1;else if exportstate = 'ilupdate then	begin	storeID := GetSlot(theData, 'storeID);	theEntry := call GetTheEntryWeWant with (storeID, refTopicFrame);	if theEntry then		begin		local indexToTopicToFind := 0;		foreach entry in theEntry.topics do			if HasSlot(entry, 'uniqueId) then				begin				if entry.uniqueId <> refTopicFrame.topic.uniqueId then					indexToTopicToFind := indexToTopicToFind + 1				else					break				end			else if HasSlot(entry, 'unique) then				begin				if entry.unique <> refTopicFrame.topic.uniqueId then					indexToTopicToFind := indexToTopicToFind + 1				else					break				end;		local theSymbolsToUpdateArray := refTopicFrame.updateArray;		local theTopicFrame := theEntry.topics[indexToTopicToFind];		foreach entry in theSymbolsToUpdateArray do			if entry = 'uniqueId then				theTopicFrame.unique := GetSlot(refTopicFrame.topic, entry)			else				theTopicFrame.(entry) := GetSlot(refTopicFrame.topic, entry);		EntryChangeXmit(theEntry, nil)		end	endelse	// exportstate = 'ilremove	try 		storeID := GetSlot(theData, 'storeID);		theEntry := call GetTheEntryWeWant with (storeID, refTopicFrame);		if theEntry then			begin			local indexToTopicToRemove := 0;			foreach entry in theEntry.topics do				if HasSlot(entry, 'uniqueId) then					begin					if entry.uniqueId <> refTopicFrame.topicID then						indexToTopicToRemove := indexToTopicToRemove + 1					else						break					end				else if HasSlot(entry, 'unique) then					begin					if entry.unique <> refTopicFrame.topicID then						indexToTopicToRemove := indexToTopicToRemove + 1					else						break					end;			ArrayRemoveCount(theEntry.topics, indexToTopicToRemove, 1);			EntryChangeXmit(theEntry, nil)			end		else			errorNumber := -1	onexception |evt.ex| do		errorNumber := -1;theEntry := nil;ep:WriteCommand("dres", errorNumber, true)end;